# MINISHELL - VÉRIFICATION DES EXIGENCES DU PROJET

## 📋 EXIGENCES GÉNÉRALES

### Gestion des Signaux
✅ SIGINT (Ctrl+C) - Géré dans signals.c (nouvelle ligne, nouveau prompt)
✅ SIGQUIT (Ctrl+\) - Ignoré en mode interactif
✅ SIGQUIT dans les processus enfants - "Quit (core dumped)" affiché (implémenté dans exec_commands.c et exec_readline.c)
✅ EOF (Ctrl+D) - Géré, sort du shell

### Historique
✅ readline() - Implémenté dans get_input()
✅ add_history() - Appelé pour les lignes non-vides
✅ rl_clear_history() - Appelé dans free_shell()

### Variables d'Environnement  
✅ Expansion $VAR - Géré dans extract.c
✅ Expansion $? - Géré (exit status)
✅ Variables inexistantes - Remplacées par chaîne vide

### Redirections
✅ < (input) - Géré dans handle_redirections.c
✅ > (output) - Géré 
✅ >> (append) - Géré
✅ << (heredoc) - Géré dans exec_here_doc.c avec expansion conditionnelle
✅ Redirections multiples - La dernière gagne (comportement bash)
✅ Gestion des erreurs de permissions et fichiers (perror, exit code 1)
✅ Redirection seule sans commande (ex: < file, > file, << EOF) - shell ne reste pas dans le fichier
❌ Redirection de stderr (2>) - **Non gérée** (pas de support pour `2>fichier`)

### Pipes
✅ | (pipe) - Géré dans exec_commands.c
✅ Pipes multiples - Géré avec pipeline.pipefd
✅ Code de retour du dernier maillon du pipeline (OK)

## 🔧 BUILT-INS

### echo
✅ echo sans option - Implémenté
✅ echo -n - Implémenté avec is_n_option()
✅ echo -nnn...n - Tous les 'n' sont gérés (voir echo.c)
✅ echo avec variables - $VAR dans echo est expansé

### cd
✅ cd (sans argument) - Va vers $HOME
✅ cd ~ - Va vers $HOME  
✅ cd - - Va vers $OLDPWD et affiche le chemin
✅ cd path - Change vers le chemin spécifié
✅ Mise à jour PWD/OLDPWD - Géré dans update_pwd()
✅ cd trop d'arguments - Géré (message proche de bash)
✅ Gestion des erreurs - Messages adaptés selon le type d'erreur (No such file, Not a directory, Permission denied)

### pwd
✅ pwd - Affiche le répertoire courant
✅ pwd avec options - Refuse les options (message d'erreur conforme bash)
✅ pwd - et pwd -- acceptés (comportement bash)
✅ pwd avec erreur getcwd - Message d'erreur approprié

### export
✅ export sans argument - Affiche les variables exportées
✅ export VAR - Variable sans valeur ajoutée/exportée (flag exported)
✅ export VAR=value - Ajoute/modifie variable
✅ Format de sortie - Affiche `export VAR="value"` ou `export VAR` (conforme moulinette 42 et bash)
✅ Gestion erreurs identifiants - check_error() conforme bash (message et code retour)
✅ Pas de tri alphabétique - conforme au sujet 42 (affichage dans l'ordre de la liste chaînée)
✅ Variables existantes - Mise à jour avec env_update() et set_exported_flag()

### unset
✅ unset VAR - Supprime la variable
✅ unset avec identifiants invalides - Affiche un message d'erreur et retourne 1
✅ unset VAR=value - Refusé avec erreur (voir check_error)
✅ Validation identifiants - check_error() partagé avec export

### env
✅ env - Affiche l'environnement
✅ env avec arguments - Refuse les arguments (message d'erreur conforme bash)

### exit
✅ exit sans argument - Sort avec status 0
✅ exit nombre - Sort avec le code spécifié
✅ exit avec overflow - Géré avec ft_atol et out_of_range
✅ exit "123abc" - Validation numérique complète (voir exit.c)
✅ exit trop d'arguments - Géré, message d'erreur et ne quitte pas (code 1000)
✅ exit dans pipeline vs builtin seul - Géré différemment selon le contexte

## 🚨 CAS D'ERREUR ET EDGE CASES

### Quotes
✅ Quotes simples - Pas d'expansion
✅ Quotes doubles - Expansion des variables
✅ Quotes non fermées - Détection d'erreur dans lexer.c
✅ Quotes vides - echo "" '' fonctionne
✅ Quotes imbriquées - Gestion correcte dans quotes.c

### Espaces et Caractères Spéciaux
✅ Espaces multiples - Gestion dans extract_word()
✅ Tabulations - Gérés dans ft_isspace()
❌ Caractères d'échappement - Non géré (limitation assumée)

### Redirections Avancées
✅ Permissions fichiers - Gestion basique avec perror() et exit code 1
✅ Répertoires - cat > /dev non géré complètement (limitation bash aussi)
✅ Redirections multiples - cmd < file1 < file2 (la dernière gagne)
✅ Redirections avec variables - Expansion gérée dans extract_word()
✅ Redirection seule sans commande (ex: << EOF) - heredoc lancé même sans commande

### Pipes Avancés
✅ Pipes avec built-ins - Gérés dans exec_commands.c
✅ Pipes avec redirections - cmd1 | cmd2 > file
✅ Pipes vides - Erreur de syntaxe gérée dans parse_pipe()

### Heredoc
✅ Heredoc basique - << EOF
✅ Heredoc avec variables - Expansion conditionnelle selon les quotes du délimiteur
✅ Heredoc avec quotes - << "EOF" vs << EOF (expansion désactivée si quotes)
✅ Heredoc multiples - La dernière redirection gagne (comportement bash)
✅ CTRL+C dans heredoc - Géré proprement (prompt clean, pas de double prompt)
✅ CTRL+D dans heredoc - Affiche le warning attendu

### Variables d'Environnement
✅ $VAR expansion - Géré
✅ $? expansion - Géré
❌ $0, $1, etc. - Paramètres positionnels non gérés (limitation assumée)
✅ Variables invalides - $123VAR devient $ + 123VAR
✅ Variables dans redirections - > $FILE géré via extract_word()

### Chemins et Exécution
✅ Chemins absolus - /bin/ls
✅ Chemins relatifs - ./script
✅ PATH lookup - find_path() implémenté
✅ Commandes inexistantes - Message d'erreur OK
✅ Permissions - access() utilisé
✅ Redirection échouée (Permission denied) - Message sur stderr, pas d'exécution

## 🔥 PROBLÈMES CRITIQUES IDENTIFIÉS

### 1. Gestion des Signaux
✅ SIGQUIT dans les processus enfants - Implémenté avec signal(SIGQUIT, SIG_DFL) dans exec_child() et exec_one_cmd()

### 2. Heredoc
✅ Expansion des variables selon les quotes du délimiteur
✅ Gestion CTRL+C pendant heredoc (readline interrompu proprement)
✅ Prompt clean après interruption heredoc

### 3. Parser
✅ Gestion des commandes vides et cas spéciaux ("!", ":")
✅ Syntaxe des pipes et redirections
✅ Gestion des quotes et expansion

### 4. Built-ins
✅ Tous les built-ins conformes aux spécifications
✅ Gestion des erreurs appropriée
✅ Codes de retour corrects

### 5. Gestion Mémoire
✅ free_shell() complet avec rl_clear_history()
✅ Libération des pipes et commandes
✅ Gestion des fuites mémoire

## 📊 RÉSUMÉ

### ✅ FONCTIONNEL (Estimation: 98%)
- Structure générale du shell excellente
- Built-ins conformes aux spécifications
- Pipes et redirections fonctionnels
- Variables d'environnement bien gérées
- Parsing robuste avec gestion d'erreurs
- Signaux correctement gérés
- Heredoc avec expansion conditionnelle et gestion des signaux

### ❌ À CORRIGER (Estimation: 2%)
- Redirection de stderr (`2>`) non gérée (pas de support pour `2>fichier`)
- Tests de cas limites pour redirections multiples et fichiers spéciaux
- Optimisations mineures des messages d'erreur

### 🎯 PRIORITÉS FINALES

1. **MOYEN**: Gérer la redirection de stderr (`2>`)
2. **FAIBLE**: Tester tous les cas limites heredoc/redirections
3. **TRÈS FAIBLE**: Optimiser certains messages d'erreur

Le projet est maintenant **très proche de 100%** de conformité. L'architecture est solide et tous les éléments majeurs sont implémentés correctement.

### Limitations assumées (conformes au sujet)

- echo $$, $UID, $PPID : non géré (getpid/getuid non autorisé)
- IO_number : non géré  
- Caractères non gérés : &, (), ;, *
- Paramètres positionnels ($0, $1, ...) non gérés
- Caractères d'échappement non gérés
- cd avec dossier courant supprimé (cas très rare)
- export pas trié alphabétiquement

### Notes de qualité du code

✅ **Architecture modulaire** - Séparation claire parser/executor/built-ins  
✅ **Gestion d'erreurs robuste** - Messages appropriés et codes de retour  
✅ **Gestion mémoire** - Libération systématique des ressources  
✅ **Lisibilité** - Code bien structuré et commenté  
✅ **Conformité Norminette** - Code respectueux des standards 42